#include <windows.h>
#include <wrl.h>
#include <wil/com.h>
#include <WebView2.h>
#include <shellapi.h>
#include <string>

using namespace Microsoft::WRL;

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

wil::com_ptr<ICoreWebView2Controller> g_controller;
wil::com_ptr<ICoreWebView2> g_webview;
HWND g_hwnd;

std::wstring GetTempHtmlPath() {
    wchar_t tempPath[MAX_PATH];
    GetTempPathW(MAX_PATH, tempPath);
    std::wstring filePath = std::wstring(tempPath) + L"exe.htm";

    HANDLE hFile = CreateFileW(filePath.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) return L"";

    HRSRC hRes = FindResourceW(nullptr, MAKEINTRESOURCE(1), L"HTML");
    if (!hRes) { CloseHandle(hFile); return L""; }

    HGLOBAL hGlobal = LoadResource(nullptr, hRes);
    if (!hGlobal) { CloseHandle(hFile); return L""; }

    DWORD size = SizeofResource(nullptr, hRes);
    void* data = LockResource(hGlobal);

    DWORD written;
    WriteFile(hFile, data, size, &written, nullptr);
    CloseHandle(hFile);

    return L"file:///" + filePath;
}

void CreateWebView(HWND hwnd) {
    CreateCoreWebView2EnvironmentWithOptions(nullptr, nullptr, nullptr,
        Callback<ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler>(
            [hwnd](HRESULT result, ICoreWebView2Environment* env) -> HRESULT {
                if (FAILED(result) || !env) return E_FAIL;

                return env->CreateCoreWebView2Controller(hwnd,
                    Callback<ICoreWebView2CreateCoreWebView2ControllerCompletedHandler>(
                        [hwnd](HRESULT result, ICoreWebView2Controller* controller) -> HRESULT {
                            if (FAILED(result) || !controller) return E_FAIL;

                            g_controller = controller;
                            wil::com_ptr<ICoreWebView2> webview;
                            controller->get_CoreWebView2(&webview);
                            g_webview = webview;

                            RECT r;
                            GetClientRect(hwnd, &r);
                            g_controller->put_Bounds(r);
                            g_controller->put_IsVisible(TRUE);

                            std::wstring path = GetTempHtmlPath();
                            if (!path.empty()) {
                                for (size_t i = 0; i < path.size(); ++i)
                                    if (path[i] == L'\\') path[i] = L'/';
                                g_webview->Navigate(path.c_str());
                            }
                            return S_OK;
                        }).Get());
            }).Get());
}

int APIENTRY wWinMain(HINSTANCE hInst, HINSTANCE, LPWSTR, int nCmdShow) {
    const wchar_t CLASS_NAME[] = L"AtomX";

    WNDCLASSW wc = {};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = CLASS_NAME;
    wc.hCursor = LoadCursorW(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    if (!RegisterClassW(&wc)) return -1;

    int w = 800, h = 600;
    int sw = GetSystemMetrics(SM_CXSCREEN);
    int sh = GetSystemMetrics(SM_CYSCREEN);
    int x = (sw - w) / 2;
    int y = (sh - h) / 2;

    g_hwnd = CreateWindowExW(
        WS_EX_LAYERED | WS_EX_TOPMOST,
        CLASS_NAME, L"AtomX",
        WS_OVERLAPPEDWINDOW,
        x, y, w, h,
        nullptr, nullptr, hInst, nullptr
    );

    if (!g_hwnd) return -1;

    SetLayeredWindowAttributes(g_hwnd, 0, 255, LWA_ALPHA);

    ShowWindow(g_hwnd, nCmdShow);
    UpdateWindow(g_hwnd);

    CreateWebView(g_hwnd);

    MSG msg;
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    g_controller = nullptr;
    g_webview = nullptr;

    return 0;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
    switch (msg) {
    case WM_LBUTTONDOWN:
        ReleaseCapture();
        SendMessageW(hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0);
        return 0;
    case WM_SIZE:
        if (g_controller) {
            RECT r;
            GetClientRect(hwnd, &r);
            g_controller->put_Bounds(r);
        }
        return 0;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    default:
        return DefWindowProcW(hwnd, msg, wp, lp);
    }
}

// Wrapper para proporcionar el punto de entrada "main" cuando el proyecto está configurado
// como aplicación de consola. Llama a wWinMain para continuar con la lógica GUI.
int main() {
    // Llamamos a wWinMain usando el handle del módulo y la línea de comandos completa.
    return wWinMain(GetModuleHandleW(nullptr), nullptr, GetCommandLineW(), SW_SHOWDEFAULT);
}
